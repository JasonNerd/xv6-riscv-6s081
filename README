# lab lazy

## 0.梳理思路

### 修改sbrk

为了实现lazy allocation，我们首先修改了sbrk函数，当要求申请更多内存时，没有按原来的调用uvmalloc,而是仅仅修改了p->sz(p时当前运行的进程)

```c
uint64
sys_sbrk(void)
{
  int addr;
  int n;

  if(argint(0, &n) < 0)
    return -1;
  addr = myproc()->sz;
  myproc()->sz+=n;
  if(n<0){
    myproc()->sz=uvmdealloc(myproc()->pagetable,addr,addr+myproc()->sz);    
  }
  return addr;
}
```

（但是如果n为负数，也就是要求shrink，那就并不要求lazy，所以直接调用uvmdealloc）
因为原来的sbrk调用了growproc,统一处理了grow/shrink,因此修改时去掉growproc

### 修改usertrap 

再运行，就会报错：

```shell
init: starting sh 
$ echo hi
usertrap(): unexpected scause 0x000000000000000f pid=3 
            sepc=0x0000000000001258 stval=0x0000000000004008 
va=0x0000000000004000 pte=0x0000000000000000 
panic: uvmunmap: not mapped

```

```c
// Remove mappings from a page table. The mappings in
// the given range must exist. Optionally free the
// physical memory.
void
uvmunmap(pagetable_t pagetable, uint64 va, uint64 size, int do_free)
{
  uint64 a, last;
  pte_t *pte;
  uint64 pa;

  a = PGROUNDDOWN(va);
  last = PGROUNDDOWN(va + size - 1);
  for(;;){
    if((pte = walk(pagetable, a, 0)) == 0)
      panic("uvmunmap: walk");
    if((*pte & PTE_V) == 0){
      printf("va=%p pte=%p\n", a, *pte);
      panic("uvmunmap: not mapped");
    }
    if(PTE_FLAGS(*pte) == PTE_V)
      panic("uvmunmap: not a leaf");
    if(do_free){
      pa = PTE2PA(*pte);
      kfree((void*)pa);
    }
    *pte = 0;
    if(a == last)
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
}
```

由uvmunmap函数的实现可知，这个报错，是因为对应pte的PTE_V没有set

确实 我们在申请内存的时候 只是增加了sz，没有实际申请内存和install pte

因此我们在trap.c的usertrap函数中 加上对应的处理：

```c
    if(r_scause()==15||r_scause()==13){
      uint64 addr=r_stval();
      addr=PGROUNDDOWN(addr);
		// 略
      for(;addr<p->sz;addr+=PGSIZE){
        char* mem=kalloc();
        if(mem==0){
          p->killed=1;
          goto end;
        }
        memset(mem, 0, PGSIZE);
        mappages(p->pagetable, addr, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U);
      }
		// 略
    }
```

因为这里实际上就是补做sbrk中没做的工作，所以可以参考uvmmalloc函数：首先从stval寄存器中拿到出错的虚拟地址，然后按页ground down得到va，再将va和p->sz之间的内存按页分配物理内存，install pte

注意此时进程是不应该被kill的，只要在最后通过调用usertrapret返回，就能实现成功运行 echo hi 了

**注意一点**：为什么会调用uvmunmap？因为修改之前的usertrap，是这样的：

```c
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
 

  if(p->killed)
    exit(-1);
```

调用了exit：

exit()函数的代码比较复杂，但是由xv6给他的注释，可以知道：该进程不会返回，而是保持在zombie状态，直到parent调用wait()

而wait函数里会释放掉该进程的内存，但是这些内存并没有实际申请，所以uvmunmap就会panic，而由panic的实现可知，最后会陷入死循环

### 处理栈溢出

按照实验指导书的提示 现在来处理栈溢出的问题

在exe()中，对guard page,调用了uvmclear,这也是该函数唯一的被调用，具体就是把guard page的pte的PTE_V clear

所谓栈溢出，在这里就体现为访问了guard page，要检测到栈溢出，有两种做法：

* 增加一个pte flag，标记是否为guard page，在上面提到的uvmclear中，set guard page的对应guard bit ，这样，在usertrap中，只要获取到faulting va对应的pte，如果guard bit 为set，那么就代表栈溢出
* 通过某种方法，记录栈底位置，即stack base,只要va低于它，就栈溢出

上面第一种方法的问题是，实验要求的vmprint,需要打印pte，这样就改变了pte

第二种做法，要麻烦一些，需要track 栈底指针

*本来想为proc增加一个属性，然后在exec函数中设置栈底指针，但是不知道为什么，usertrap在exec中设置栈底指针之前就被调用了，也不是uvmunmap调用的，nlp-shell同学是第二种方法，以后可以看看他的，先选第一种吧*

如上所述 这里采用在pte中增加一个标志位PTE_G来标识一个页是否是guard page

这样，在usertrap中，只要判断该bit为1，那么即代表栈溢出 此时应该kill 然后exit

既然我们增加了一个属性 那么也应该相应的增加对其的初始化 注意这里虽然是对pte的初始化 但是是对用户栈下面guard page的初始化